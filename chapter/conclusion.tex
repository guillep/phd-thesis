\input{chapter-header.tex}
% =============================================================================
\chapter{Conclusion}
\chaplabel{conclusion}
\minitoc
% =============================================================================
\introduction

Software inevitable changes and we need to provide with the tools and methodologies that support such changes~\cite{Nier08b}. However, production-ready applications are not usually change-aware. These applications should be either engineered from scratch with change in mind, or a lot of reengineering effort should be invested in them to support change. Making deep modifications to a language runtime can be a cumbersome task.
At the same time, evolving a language runtime has become an important task in the last years. Multicore hardware brought new problems on concurrency and parallelism; the \emph{cloud} increased the need for software adaptation; new resource constrained devices such as phones are as current as almost every person has one in their our pockets. These new technologies present new challenges to software developers. The software we use, and in particular the programming languages and tools we use should be easily tailorable to support many of the new challenges that come with new technology and needs.

The complexity and unclear interactions between different runtime components such as \VMs and the languages that run on top of it make such evolution challenging. This thesis explores two different language runtime evolution scenarios through their virtualization. We present our virtualization model called \Vtt, a language bootstrapping process and infrastructure and RFG, an application runtime tailoring technique.

% =============================================================================
\section{Contributions}
% =============================================================================

This thesis explores the evolution of an application and language runtime through \emph{\Vtt, a language virtualization infrastructure}. In \Vtt, a first-class runtime system, namely an object space, allows the manipulation, control and monitoring of such runtime system through a clear API. A first-class language hypervisor implements such runtime manipulations with the expression power and abstractions of the high-level language we are manipulating. We validate this approach by exploring two different evolution scenarios: bootstrapping and tailoring.

\emph{Bootstrapping} is commonly known by its usage on compiler building, where a compiler can compile itself.
It can be generalized to the introduction of any software system to its own building process.
A bootstrap process allows us to easily change this system as it is expressed in terms of itself, taking advantage of its abstractions and tools.
Our virtualization infrastructure eases this bootstrap process by providing a clear VM-language interface to manipulate the runtime system of the language under creation. It also provides with a bootstrapping interpreter that allows the manipulation of the bootstrapped language in terms of itself, and not manipulating chunks of memory.
We show how by this infrastructure can be used to bootstrap three different object-oriented languages with different programming models: a minimal small-talk with implicit metaclasses, the core of the Pharo language which is defined by traits, and finally Metatalk which decomposes reflection from the base level and stores meta information in the meta level of the language.

\emph{Tailoring} is a technique that specialized an application runtime to contain only code units that will be used at runtime. We presented our run-fail-grow~(RFG) approach for application tailoring. RFG tailors an application by starting it and initializing it with a seed that contains the minimal set of code units we want to ensure. Then, we install and execute the application's entry points. As the application executes, missing code units are found and installed on demand, ensuring that only the needed code units are introduced. By following the runtime execution, it supports dynamic features such as reflection and meta-programming. Tornado, our RFG implementation, succeeds to produce applications with minimal footprint for deployment. Our results show that we manage different extreme and challenging cases with flexibility.

% =============================================================================
\section{Published Papers}
% =============================================================================

\subsection{Journals}

Guillermo Polito, Stéphane Ducasse, Luc Fabresse, Noury Bouraqadi, and Benjamin Ryseghem. Bootstrapping Reflective Systems: The Case of Pharo. In Science of Computer Programming, 2013. Impact Factor: 0,548\newline



tornado (under submission spe)

\subsection{Workshops}

Clara Allende, Guillermo Polito. Virtual Smalltalk Images: Model and Applications. In WISIT - Workshop de Ingeniería en Sistemas y Tecnologías de la Información, 2014.
Guillermo Polito, Stéphane Ducasse, Luc Fabresse, and Noury Bouraqadi. Understanding Pharo’s global state to move programs through time and space. In IWST - International Workshop on Smalltalk Technology, Co-located within the 22th International Smalltalk Conference - 2014, 2014.
Guillermo Polito, Stéphane Ducasse, Luc Fabresse, and Noury Bouraqadi. Virtual Smalltalk Images: Model and Applications. In IWST - International Workshop on Smalltalk Technology, Co-located within the 21th International Smalltalk Conference - 2013, 2013.

\section{Future Work}

\Vtt presents a language runtime virtualization model that opens several lines of future work that we consider for exploration.

\begin{description}

\item[Security.] Virtualization opens the door to easily forbid or constraint operations to the virtualized runtime. Sandboxing can then be transparent to the virtualized application, which may believe that it \emph{owns} the entire machine for itself.

\item[Resource Control.] An application could be virtualized to restrict its consumption of critical resources such as CPU or memory. Doing so in a flexible way with our first class runtimes would simplify \eg the creation of simulators for specific platforms such as constrained devices.

\item[Application distribution and migration.] The virtual language runtime API exposed by an object space encapsulates the internals of the implementation. This same API may provide transparent access to remote application runtimes residing in different processes/machines. This could open the possibility of exploring application distribution and migration in the \emph{cloud} at the language level.

\item[Dynamic Adaptation.] Language virtualization can be also useful in the context of dynamic adaptation of applications with almost zero downtime. An object space API is general enough to allow updates to occur at runtime. Additionally, the execution cycles provides with atomicity for doing such changes.

\item[VM-Language Co-Evolution.] Our approach doesn't address the co-evolution of language and VM. However, object spaces make explicit the border-line between the VM and the language to change the latter. A co-evolution implies changing not only language and VM but also their interface.

\end{description}

% =============================================================================
\section{Software Artifacts}

The research that appears in this thesis was supported and validated by several prototypes implemented in the course of the P.h.d. The produced software artifacts are the following:

\begin{description}

\item[\Vtt.] \Vtt's prototype is the main software artifact that results from this research. This prototype included changes in the Pharo \VM to allow the described co-existence, manipulation and control of a language runtime. \Vtt also includes several language libraries that expose the \VM behavior: object spaces and its mirrros encapsulate a language runtime; a \Vtt-based AST interpreter was created from an existent AST interpreter in Pharo; a heap exporter and importer allowed us to work on existing smalltalk images.

\item[Hazelnut/Seed.] Hazelnut/Seed is our bootstrapping solution for the Pharo language. Hazelnut describes a language runtime and allow its creation through a bootstrapping interpreter based on \Vtt's one.

\item[Tornado.] Tornado is our tailoring implementation on top of \Vtt. Tornado uses the Ghost proxies model to implement execution traps and the \Vtt execution cycle to install code when missing code is detected.

\end{description}

% =============================================================================
\input{chapter-footer.tex}