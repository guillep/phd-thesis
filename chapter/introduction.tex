\input{chapter-header.tex}
% =============================================================================
\chapter{Introduction}
\chaplabel{introduction}
\minitoc
% =============================================================================


%Reflective systems are those that reason about and act upon themselves \cite{Smit84a}. A causal connection exists between the program and its representation inside the program itself as a meta-program \cite{Maes87a}. This reflective architecture introduces self-references:  an object-oriented system is composed by objects, which are instances of classes, which are also objects, and so on. These self-references, also known as meta-circularities \cite{Chib96a}, allow the manipulation of several meta-levels on one infrastructure.
%
%Reflective systems traditionally modify their self-representation to evolve and define new abstractions. However, the self-modification approach of evolution has many drawbacks, such as making difficult the self-surgery operations~\cite{Casa09a} or the lose of the reproducibility of the system. On the other hand, non-reflective systems develop an evolution approach by recreation. Whenever a change has to be made to the system, a new system is created with the new changes applied. This approach solves many of the drawbacks of the reflective approach.
%
%\gp{add some sentences on why it is important to evolve, which kind of software artifacts we would like to evolve, why it is challenging}

% =============================================================================
%\section{The need for Software Evolution}
% =============================================================================

An application runtime is the set of software elements that denotes an application during its execution. Narrowing to high-level object-oriented applications, an application runtime includes \eg the loaded libraries, classes and methods, the created objects and the running application threads. Within an application runtime, we find the \emph{language runtime}. The language runtime is the subset of the application runtime that denotes the concepts and behavior available in the language we use \ie the set of structures and constructs that describe the language internals. The language runtime concretizes the model that the language proposes to the developers.

Manipulating and modifying these language runtimes, and therefore their models, is becoming important in the last years. Multicore hardware brought new problems on concurrency and parallelism; the \emph{cloud} increased the need for software adaptation; new resource constrained devices such as phones are spread in a way that almost every person has one powerful computer in their our pockets. These new technologies present new challenges to software and language developers. The software we use, and in particular the programming languages and tools we use should be easily tailorable to support many of the new challenges that come with new technology and needs.

We observe, however, that software is not usually designed and thought to easily accept changes. Applications and languages should be either engineered from scratch with change in mind, or a lot of reengineering effort should be invested in them to support change. We need to provide with the tools and methodologies that support such changes~\cite{Nier08b}. The languages and applications we develop should be adaptable to new situations and scenarios. In this direction we propose \emph{\Vtt}: a runtime virtualization infrastructure. \Vtt virtualizes an application runtime for its control and manipulation. This manipulation is transparent for the virtualized runtime. We show how \Vtt simplifies application and language runtime manipulation in two different scenarios: the language runtime recreation by bootstrapping and the application runtime extraction to reduce its memory consumption.


%For example, an application runtime should be easily tailorable to consume less resources. We can observe that deployed applications contain a set of \emph{code units} such as classes and methods that tend to occupy more memory~(primary and secondary) than necessary.
%This problem shows itself more evident and harder to control under the usage of third party software. 
%Third party libraries and frameworks are designed in a generic fashion that allows multiple usages and functionalities, while applications use only few of them. 
%Examples are logging libraries, web application frameworks or object-relational mappers.
%Unused code units represent serious drawbacks in constrained devices. 
%First, unused code units may forbid the deployment into a constrained resource device.
%It may also interfere with the deployment and usage of other applications, because of large memory footprints in both secondary~(disk storage) and primary~(RAM) memory~\cite{Mart12a} or the presence of slow networks in the case of rich web applications.
%Second, some deployment targets may have an infrastructure designed in such a manner that forbids the deployment of large applications. For example, the Android's Dalvik VM restricts an application to deploy only 65536 methods.


% =============================================================================
%\section{The cloud and Mobile code}
% =============================================================================

%\gp{explain why code mobility is important!}

%Another example of support that should be brought to user applications is \emph{code mobility}. Code mobility is a mechanism that allows the migration of programs between different environments. This problem is important in the context of ubiquitous systems and virtualization technology. Code mobility provides support for \eg load balancing, adjusting an application's resources dynamically and functionality customization. However, applications must have support to rebind a piece of code or object to another location~\cite{Fugg98a}.

% =============================================================================
\section{Application Runtime Dissection}
% =============================================================================

In the context of application runtime manipulation, we ask ourselves the following question: \emph{What are the elements of high-level programming languages we should focus on?} High-level application runtimes are inherent complex pieces of software. 
This section proposes a dissection of a high-level language application runtime. We made this dissection with the objective of understanding the relation and separation between the software elements we believe important in the context of this thesis. This section do also state the terminology used during the rest of this dissertation. Figure \ref{fig:whatToEvolve} shows an schema of this dissection.

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=0.5\linewidth]{elements_to_evolve}
\caption{\textbf{Dissection of a running program to evolve.}\label{fig:whatToEvolve} We identify the application and language runtimes that represent respectively the particular application under execution and the language that provides support for it. The \VM provides as well an execution support for the application runtime. The overlapping shows the interrelations between these three components.}
\end{center}
\end{figure}

\subsection{Application Runtime}

An application runtime is the set of software elements that denotes an application during its execution. An application runtime includes software elements that describe the application's structure, such as its libraries, classes and methods, and elements related with the application's execution, such as threads, the execution stack with its activation records and created objects.

An application runtime usually follows the model and concepts imposed by the language it is written on. For example, Smalltalk or Ruby propose that an application is structured in classes with implicit metaclasses \ie a class is instance of a (\emph{meta})class that describes its behavior. Thus, the application runtime of a Smalltalk or Ruby application is structured in those terms also, each class will have a metaclass.

\subsection{Language Runtime}

The \emph{language runtime} is the subset of the application runtime that describes the concepts and behavior available in the language we use \ie the set of structures and constructs that describe the language internals. The language runtime concretizes the model that the language proposes to the developers. For example, in Smalltalk and Ruby there exist structures that represent the concepts of a \ct{Class} and \ct{Metaclass} and control the implicit creation of a metaclass for each class we create. Additionally, a language runtime is not only composed by classes but also by other objects. For example, it contains a table of interned strings or \emph{symbols} that should be guaranteed unique at runtime.

\subsection{Virtual Machine}

High-level languages virtual machines~(\VMs) provide with support for executing an application runtime.
\VMs concentrate several complex and interconnected elements with two main purposes: first it is to abstract applications from details such as memory management or machine specifics; second it is to do that while also obtaining good performance.
The early \VMs focused on interpreting an abstract instruction set (bytecodes).
On the one hand the bytecodes guarantee certain platform independence by abstracting away from the \CPU specific instruction set.
On the other hand bytecodes allow one to encode complex operations into little space both serving the hard memory constraints of the hardware and simplifying the design of a compiler.
Obviously this abstraction gain comes at a cost, and ever since the first \VMs were built, research and industry strive to reduce the interpretation overhead.

%This goes even so far that specialized hardware is conceived to match the performance requirements \cite{Unga84a,Stef84a,McGh98a,Clic05a}.

To improve performance some \VMs use a just in time compiler (\JIT) that dynamically generates native code from the bytecode \cite{Deut84a}.
In this case the bytecode becomes an intermediate representation (\IR) for a bigger compiler infrastructure.
However, \JIT compilers are notoriously complex as they crosscut many \VM components.
At the same time they crosscut all abstraction layers; they have to access high-level information from the running bytecodes and manage native code at the same time.
Similar complexity applies to the automatic memory management present in most high-level language \VMs.
Garbage Collectors (\GC) evolved from simple helpers to complex software artifacts that for instance support concurrent garbage collection \cite{Clic05a}.

These complex \VMs are the enablers of many of the features in our programming languages. However, their complexity constrain the changes we can apply to our application runtimes. For example, adding a new field into the classes of an application runtime may impact the bytecode interpreter, the JIT, the GC, and so on. These constraints denote the \emph{execution model} of a \VM \ie the contract required to a language runtime to execute it. This execution model includes the format in which the runtime elements are layout in memory~(objects, classes, methods), the followed object model (\eg class-based or prototype-based) and the instruction set that the runtime must implement.

\section{Problem Statement}

We focus this thesis in the manipulation of object-oriented high-level application and language runtimes. In such context, we identify as a general problem for this thesis the lack of an infrastructure for safe application runtime manipulation. By this we mean the ease of change of the structures that represent an application at runtime. This infrastructure must allow both the specialization and extension of application and language runtimes.

Particularly, we indentify these more concrete problems:
\begin{description}
\item[Unclear \VM-Language interface.] The relation between the language and the \VM, particularly its execution model, remains often unclear in \VM hardcoded assumptions.
\item[Core runtime changes remain low-level.] Changing a language or application runtime representation often forces us to modify the low-level code that defines such a runtime.
\end{description}


\section{Contributions}

The contributions of this thesis are three-fold. The main contribution is \Vtt, an \emph{infrastructure for application runtime virtualization}. This infrastructure allows us to manipulate and control a virtualized application's runtime. \Vtt exposes the \VM-language interface as a first-class runtime object, namely an object space. An object space clarifies and makes explicit such interface, and provides with a high-level API for its manipulation.

We validate our language virtualization infrastructure by exploring two approaches for application runtime manipulation.
\begin{description}
\item[Bootstrapping.] We describe the process to create a language runtime through \emph{bootstrapping} with \Vtt. Our bootstrapping process provides a novel way to define an object-oriented language runtime by using the definition of the language to define itself.
\item[Application tailoring.] We developed a novel dynamic application tailoring approach based on lazy installation, namely Run-Fail-Grow~(RFG). \Vtt supports RFG by allowing the monitoring of the application under extraction and provide with facilities for code installation.
\end{description}

% =============================================================================
\section{Thesis Outline}
% =============================================================================
%\sm{This dissertation structure is different to what I am used to. At least the way you announce the purpose of the chapters is not what I would expect.
%In my diss, everything revolves around one thesis, here, it is a number of things listed one after another, don't see the central motive I would expect}

\gp{write from scratch, left for the end}
\begin{description}
\item[\chapref{background}] 

\item[\chapref{benzo}] 
	
\item[\chapref{ffi}] 

\item[\chapref{validation}] 

\item[\chapref{conclusion}] 

\end{description}


% =============================================================================
\input{chapter-footer.tex}
% =============================================================================